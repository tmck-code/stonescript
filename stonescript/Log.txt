func longestLength(l)
  var longest = 0
  for i = 0 .. l.Count()-1
    longest = math.Max(longest, string.Size(l[i]))
  return longest

func LogStrat(y, l, colour)
  >`0,0,@colour@,strat: @l@

// e.g. LogStrat(["#red", "attack"], 0, "right", -1)
// umm, does that example seem correct?

func LogAbovePlayer(l, x_offset, y_offset, increment, alignment)
  ?l.Count() = 0
    return
  
  for i = 0 .. l.Count()-1
    var colour = l[i][0]
    var msg = l[i][1]
    var y = (i*increment)+y_offset
    ?alignment = "right"
      >o@x_offset-string.Size(msg))@,@y@,@colour@,@msg@
    :?alignment = "left"
      >o@x_offset@,@y@,@colour@,@msg@

func LogTopLeft(l)
  for i = 0 .. l.Count()-1
    var colour = l[i][0]
    var k = l[i][1]
    var value = l[i][2]
    >`0,@i+1@,@colour@,@k@: @value@

func LogLowerLeft(x, y, color, message)
  y = y + screen.h
  >`@x@,@y@,@color@,@message@

func LogLowerRight(x, y, color, message)
  x = x + screen.w
  y = y + screen.h
  >`@x@,@y@,@color@,@message@

func LogTopRight(x, y_offset, messages)
  ?messages.Count() = 0
    return
  var longest = 0
  for i = 0 .. messages.Count()-1
    longest = math.Max(longest, string.Size(messages[i][1]))
  var msg
  var color
  for i = 0 .. messages.Count()-1
    color = messages[i][0]
    msg = messages[i][1]
    // x pos = 
    //   width (go to right of screen)
    // - longest string (make sure they all fit)
    // + offset (align to the right)
    var x = screen.w - longest + (longest - string.Size(msg))
    >`@x@,@y_offset+i+1@,@color@,@msg@

// formatting ----------------------------------------

func FmtValue(value)
  var msg = []
  ?Type(value) ! array
    return string.Format("{0}", value)

  for i = 0 .. value.Count()-1
    ?Type(value) = array
      msg.Add(FmtValue(value[i]))
    :
      msg.Add(string.Format("{0}", value[i]))
  return "["+string.Join(",", msg)+"]"

func FmtWithSep(data, sep)
  var strParts = []
  for i = 0 .. data.Count()-1
    strParts.Add(FmtValue(data[i]))
  return string.Join(sep, strParts)

func Fmt(data)
  return FmtWithSep(data, " ")

// returns an array of [color, message, remainingCooldown]
func FormatCooldownLog(weapon)
  var remaining = item.GetCooldown(weapon)
  var canUse = remaining <= 0 & item.CanActivate()
  var msg = string.Format("{0}: {1}", weapon, remaining)
  ?!item.CanActivate()
    return ["#red", msg, remaining]
  :?remaining > 200
    return ["#red", msg, remaining]
  :?remaining > 100 & remaining <= 200
    // orange
    return [color.FromRGB(255,102,0), msg, remaining]
  :?remaining > 0
    return ["#yellow", msg, remaining]
  :
    return ["#green", msg, remaining]

func FormatCooldownLogs(weapon_ids)
  var logs = []
  for i = 0 .. weapon_ids.Count()-1
    var formatted = FormatCooldownLog(weapon_ids[i])
    ?formatted[2] > 0
      logs.Add(formatted)
  return logs

func FormatSpecialWeaponName(weapon)
  ?weapon = "blade"
    return "Blade of the Fallen God"
  ?weapon = "bardiche"
    return "Bardiche"
  ?weapon = "quarterstaff"
    return "Quarterstaff"
  ?weapon = "heavy_hammer"
    return "Heavy Hammer"
  ?weapon = "skeleton_arm"
    return "Skeleton Arm"
  ?weapon = "mask"
    return "Mask"
  ?weapon = "fissure_stone"
    return "Fissure Stone"
  return false

func FormatCraftedWeaponName(weapon)
  var parts = string.Split(weapon, ",")
  return string.Join("\n", parts)

func FormatWeaponName(weapon)
  var fmt = FormatSpecialWeaponName(weapon)
  ?fmt ! false
    return fmt
  return FormatCraftedWeaponName(weapon)

// --------------------------------------------------
// State Formatting

func FmtItemState(item_state, item_hand)
  ?item_state = 1
    return "idle"
  :?item_state = 2
    return "cast"
  :?item_state = 3
    return "perf"
  :?item_state = 4
    return "cool"
  :
    return string.Format("?? {0}", item_state)

func FmtItemStateVis(item_state)
  // 1 is idle/checking for targets
  ?item_state = 1
    return "|     "
  // 2 is cast/ pre-damage animation
  :?item_state = 2
    return "|==>  "
  // 3 is perf/ post-damage animation
  :?item_state = 3
    return "|==> ~"
  // 4 is cooldown, waiting until it can be used again
  // (for regular attacks, abilities dont use it)
  :?item_state = 4
    return "xxxxxx"

func FmtFoeState(foe_state)
  ?foe_state = 32
    return "attack prepare"
  :?foe_state = 33
    return "attack do"
  :?foe_state = 34
    return "attack done"
  :?foe_state = 2
    return "waiting..."
  :
    return string.Format("??: {0}", foe_state)
  

var seenItemStatesLeft = []
var itemStateTimesLeft = []
var seenItemStatesRight = []
var itemStateTimesRight = []

var seenFoeStates = []
var foeStateTimes = []

?loc.loop
  seenItemStatesLeft.Clear()
  itemStateTimesLeft.Clear()
  seenItemStatesRight.Clear()
  itemStateTimesRight.Clear()
  seenFoeStates.Clear()
  foeStateTimes.Clear()

func CollectStates(state_name, foe_state, foe_time, seen_states, state_times)
  var stateValue = FmtFoeState(foe_state)

  var t = foe_time
  var idx = seen_states.IndexOf(foe_state)
  ?idx = -1
    seen_states.Add(foe_state)
    state_times.Add(t)
  :?time % 2 = 0
    state_times.Emplace(idx, t)

  var lines = []
  for i = 0 .. seen_states.Count()-1
    ?i = idx
      lines.Add(["#green", string.Format(" {0}:{1}", seen_states[i], state_times[i])])
    :
      lines.Add(["#white", string.Format(" {0}:{1}", seen_states[i], state_times[i])])
  return lines

var lastLeftItem = ""
var lastRightItem = ""
var lastFoe = ""

func LogAllStates()

  ?lastLeftItem ! item.left.id | string.Size(item.left.id) = 0
    seenItemStatesLeft.Clear()
    itemStateTimesLeft.Clear()
    lastLeftItem = item.left.id
  :
    var leftItemLines = CollectStates(item, item.left.state, item.left.time, seenItemStatesLeft, itemStateTimesLeft)
    ?leftItemLines.Count() > 0
      >`0,7,#yellow,@string.Sub(item.left, 0, math.Min(5, string.Size(item.left)))@
      for i = 0 .. leftItemLines.Count()-1
        >`0,@i+8@,@leftItemLines[i][0]@,@leftItemLines[i][1]@

  ?lastRightItem ! item.right.id | string.Size(item.right.id) = 0
    seenItemStatesRight.Clear()
    itemStateTimesRight.Clear()
    lastRightItem = item.right.id
  :
    var rightItemLines = CollectStates(item, item.right.state, item.right.time, seenItemStatesRight, itemStateTimesRight)
    ?rightItemLines.Count() > 0
      >`6,7,#yellow,@string.Sub(item.right, 0, math.Min(5, string.Size(item.right)))@
      for i = 0 .. rightItemLines.Count()-1
        >`6,@i+8@,@rightItemLines[i][0]@,@rightItemLines[i][1]@

  ?lastFoe ! foe.id | string.Size(foe.id) = 0
    seenFoeStates.Clear()
    foeStateTimes.Clear()
    lastFoe = foe.id
  :
    LogTopRight(-15, 8, [["#yellow", foe.id]])
    var foeLines = CollectStates(foe, foe.state, foe.time, seenFoeStates, foeStateTimes)
    LogTopRight(-15, 9, foeLines)

func cleanBuffString(b, buff_type)
  var idx = string.IndexOf(b, buff_type)
  var buffLen = string.Size(buff_type)
  ?idx = -1
    return b
  
  // it's a buff_: [idx: 0, len: ->]
  ?idx = 0
    return string.Sub(b, buffLen+1)
  // there's a _ before the buff name
  ?string.IndexOf(b, "_", idx-1) ! idx-1
    return b
  // it's a _debuff: [idx: suffix, len: total - length of suffix]
  ?idx-1 = string.Size(b)-(buffLen+1)
    return string.Sub(b, 0, idx-1)
  // it's a _debuff_ in the middle: [idx: suffix, len: total - length of suffix]
  return string.Sub(b, idx+(buffLen+1))

// Formats a string of buffs or debuffs, returning 
// - an array of [color, message] tuples,
// - the longest message size, to use for right-aligning messages
func FmtBuffs(buff_string, buff_type, colour)
  var bfs = []
  var msgs = []

  // check if there are any buffs
  ?string.Size(buff_string) = 0 | string.Equals(buff_string, ",")
    return []
  :
    // if there is only one buff, it won't have a comma
    ?string.IndexOf(buff_string, ",") = -1
      bfs = [buff_string]
    :
      // split the string into an array of buffs
      bfs = string.Split(buff_string, ",")

  var t = ""
  var b = ""
  var c = ""
  var buffTypeLen = string.Size(buff_type)
  // var debuffLen = string.Size("debuff")
  // var buffLen = string.Size("buff")

  ?bfs.Count() = 0
    return []

  // for each buff
  for i = 0 .. bfs.Count()-1
    b = ""
    // if the buff is formatted as
    // "buff:buff_name:level:time_remaining"
    ?string.Size(bfs[i]) = 0
      continue

    ?string.IndexOf(bfs[i], ":") ! -1
      var parts = string.Split(bfs[i], ":")
      c = parts[0]
      b = parts[1]
      t = parts[3]
    :
      // otherwise, the buff is formatted as
      // "buff_string:time_remaining"
      b = bfs[i]
      t = ""
    ?string.Size(b) = 0
      continue

    b = cleanBuffString(b, buff_type)
    msgs.Add([colour, string.Format("{0} {1}:{2}", c, b, t) ])
    continue

  ?msgs.Count() = 0
    return []

  return msgs

func FmtBossHealth()
  ?foe = boss & foe.hp > 0
    return string.Format("{0}/{1} {2}%", foe.hp, foe.maxhp, foe.hp*100/foe.maxhp)
  :
    return string.Format("{0}/{1} {2}%", foe.hp, foe.maxhp, 0)


// --------------------------


func LogAllBuffsAndDebuffs()
  // [colour,msg] tuples
  var playerBuffs = FmtBuffs(buffs.string, "buff", "#green")
  var playerDebuffs = FmtBuffs(debuffs.string, "debuff", "#red")

  var foeBuffs = FmtBuffs(foe.buffs.string, "buff", "#green")
  var foeDebuffs = FmtBuffs(foe.debuffs.string, "debuff", "#red")

  LogAbovePlayer(playerBuffs,   -3, -2, -1, "right")
  LogAbovePlayer(playerDebuffs, -3, -1,  1, "right")
  LogAbovePlayer(foeBuffs,       4, -2, -1, "left")
  LogAbovePlayer(foeDebuffs,     4, -1,  1, "left")

// --------------------------

var bossFinished
?time <= 10
  bossFinished = false
:?foe = boss
  ?foe.hp <= 100
    bossFinished = true
  :
    bossFinished = false

var orange = color.FromRGB(255,102,0)

LogTopLeft([
  ["#white",  "t", Fmt([totaltime, time.FormatCasual(totaltime, true)])],
  ["#white",  "f", Fmt([foe.id])],
  ["#yellow", "l",   Fmt([item.left.gp,  FmtItemStateVis(item.left.state),  item.left.time])],
  [orange,    "r",   Fmt([item.right.gp, FmtItemStateVis(item.right.state), item.right.time])],
  ["#blue",   "key", Fmt([string.Break(key, 15)[0]])],
])

LogTopRight(-20, 0, [["#green", Fmt([foe.state, foe.time])]])
LogTopRight(-20, 1, [["#green", Fmt([FmtBossHealth()]) ]])

?!bossFinished
  LogTopRight(-15, 2, FormatCooldownLogs([
  ^  "blade", "bardiche", "quarterstaff", "heavy_hammer",
  ^  "skeleton_arm", "mask", "fissure_stone",
  ^]))

// log buffs and debuffs above the player
LogAllBuffsAndDebuffs()
LogAllStates()
LogAbovePlayer([["#yellow", foe.distance]], 0, -2, -1, "left")